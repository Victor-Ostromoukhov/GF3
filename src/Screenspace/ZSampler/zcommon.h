/*
 * Shared data and code for all Z-ordering samplers.
 * 2020-08-17: Created by Abdalla Ahmed.
 */

// samplers/zcommon.h*

#ifndef PBRT_SAMPLERS_Z_COMMON_H
#define PBRT_SAMPLERS_Z_COMMON_H

// The smallest float fraction of 1:
#define ONE_IN_2E32 (Float(2.3283064365386963e-10))

// Invariant parameters:
const uint32_t mask1D = 1;                                                      // Mask for a single bit
const uint32_t mask2D = 3;                                                      // Mask for a base-4 digit, i.e. 2 bits
const unsigned shift1D = 1;                                                     // Shift of 1 bit
const unsigned shift2D = 2;                                                     // Shift of base-4 digit

struct TileInfo {
    uint32_t id;
    uint32_t seqNo;
};

const unsigned char childNo2rank[24][4] = {                                     // The order is arbitrary.
    {0, 1, 2, 3},
    {0, 1, 3, 2},
    {0, 2, 1, 3},
    {0, 2, 3, 1},
    {0, 3, 1, 2},
    {0, 3, 2, 1},
    {1, 0, 2, 3},
    {1, 0, 3, 2},
    {1, 2, 0, 3},
    {1, 2, 3, 0},
    {1, 3, 0, 2},
    {1, 3, 2, 0},
    {2, 0, 1, 3},
    {2, 0, 3, 1},
    {2, 1, 0, 3},
    {2, 1, 3, 0},
    {2, 3, 0, 1},
    {2, 3, 1, 0},
    {3, 0, 1, 2},
    {3, 0, 2, 1},
    {3, 1, 0, 2},
    {3, 1, 2, 0},
    {3, 2, 0, 1},
    {3, 2, 1, 0}
};
const unsigned char rank2childNo[24][4] = {                                     // An inverse permutation of p may be obtained using: echo {0, 1, 2, 3} | tr $p 0123
    {0, 1, 2, 3},
    {0, 1, 3, 2},
    {0, 2, 1, 3},
    {0, 3, 1, 2},
    {0, 2, 3, 1},
    {0, 3, 2, 1},
    {1, 0, 2, 3},
    {1, 0, 3, 2},
    {2, 0, 1, 3},
    {3, 0, 1, 2},
    {2, 0, 3, 1},
    {3, 0, 2, 1},
    {1, 2, 0, 3},
    {1, 3, 0, 2},
    {2, 1, 0, 3},
    {3, 1, 0, 2},
    {2, 3, 0, 1},
    {3, 2, 0, 1},
    {1, 2, 3, 0},
    {1, 3, 2, 0},
    {2, 1, 3, 0},
    {3, 1, 2, 0},
    {2, 3, 1, 0},
    {3, 2, 1, 0}
};

inline uint32_t Sobol32(
    uint32_t seqNo,
    const uint32_t *matrix,
    uint32_t scramble = 0
) {                                                                             // Same as PBRT's sobol function, but return an integer
    for (int i = 0; seqNo; i++, seqNo >>= 1) {
        if (seqNo & 1) scramble ^= matrix[i];
    }
    return scramble;
}

/* Sobol matrices */
// utilise matrices Sobol (0,1)
//~ #define ZSOBOL01 

// utilise matrices Zsampler
#undef ZSOBOL01  

/*
 *    Matrix_0231:                                                              // We added these below-diagonal ones to break the strong diagonal alignment in the original Sobol sequence
 *        1...............................
 *        11..............................
 *        ..1.............................
 *        ..11............................
 *        ....1...........................
 *        ....11..........................
 *        ......1.........................
 *        ......11........................
 *        ........1.......................
 *        ........11......................
 *        ..........1.....................
 *        ..........11....................
 *        ............1...................
 *        ............11..................
 *        ..............1.................
 *        ..............11................
 *        ................1...............
 *        ................11..............
 *        ..................1.............
 *        ..................11............
 *        ....................1...........
 *        ....................11..........
 *        ......................1.........
 *        ......................11........
 *        ........................1.......
 *        ........................11......
 *        ..........................1.....
 *        ..........................11....
 *        ............................1...
 *        ............................11..
 *        ..............................1.
 *        ..............................11
 */
const uint32_t ZMatrix1stD[32] = 
#ifndef ZSOBOL01
{
    0xC0000000,    0x40000000,    0x30000000,    0x10000000,
    0x0C000000,    0x04000000,    0x03000000,    0x01000000,
    0x00C00000,    0x00400000,    0x00300000,    0x00100000,
    0x000C0000,    0x00040000,    0x00030000,    0x00010000,
    0x0000C000,    0x00004000,    0x00003000,    0x00001000,
    0x00000C00,    0x00000400,    0x00000300,    0x00000100,
    0x000000C0,    0x00000040,    0x00000030,    0x00000010,
    0x0000000C,    0x00000004,    0x00000003,    0x00000001
};
#else
{
    0x80000000, 0x40000000, 0x20000000, 0x10000000, 
    0x8000000, 0x4000000, 0x2000000, 0x1000000, 
    0x800000, 0x400000, 0x200000, 0x100000, 
    0x80000, 0x40000, 0x20000, 0x10000, 
    0x8000, 0x4000, 0x2000, 0x1000, 
    0x800, 0x400, 0x200, 0x100, 
    0x80, 0x40, 0x20, 0x10, 
    0x8, 0x4, 0x2, 0x1
};
#endif

/*
 *    Matrix_Sobol2: Sobol second matrix
 *        11111111111111111111111111111111
 *        .1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1
 *        ..11..11..11..11..11..11..11..11
 *        ...1...1...1...1...1...1...1...1
 *        ....1111....1111....1111....1111
 *        .....1.1.....1.1.....1.1.....1.1
 *        ......11......11......11......11
 *        .......1.......1.......1.......1
 *        ........11111111........11111111
 *        .........1.1.1.1.........1.1.1.1
 *        ..........11..11..........11..11
 *        ...........1...1...........1...1
 *        ............1111............1111
 *        .............1.1.............1.1
 *        ..............11..............11
 *        ...............1...............1
 *        ................1111111111111111
 *        .................1.1.1.1.1.1.1.1
 *        ..................11..11..11..11
 *        ...................1...1...1...1
 *        ....................1111....1111
 *        .....................1.1.....1.1
 *        ......................11......11
 *        .......................1.......1
 *        ........................11111111
 *        .........................1.1.1.1
 *        ..........................11..11
 *        ...........................1...1
 *        ............................1111
 *        .............................1.1
 *        ..............................11
 *        ...............................1
 */

const uint32_t ZMatrix2ndD[32] = 
#ifndef ZSOBOL01
{
    0x80000000,    0xC0000000,    0xA0000000,    0xF0000000,
    0x88000000,    0xCC000000,    0xAA000000,    0xFF000000,
    0x80800000,    0xC0C00000,    0xA0A00000,    0xF0F00000,
    0x88880000,    0xCCCC0000,    0xAAAA0000,    0xFFFF0000,
    0x80008000,    0xC000C000,    0xA000A000,    0xF000F000,
    0x88008800,    0xCC00CC00,    0xAA00AA00,    0xFF00FF00,
    0x80808080,    0xC0C0C0C0,    0xA0A0A0A0,    0xF0F0F0F0,
    0x88888888,    0xCCCCCCCC,    0xAAAAAAAA,    0xFFFFFFFF,
};
#else
{
    0x80000000, 0xc0000000, 0xa0000000, 0xf0000000, 
    0x88000000, 0xcc000000, 0xaa000000, 0xff000000, 
    0x80800000, 0xc0c00000, 0xa0a00000, 0xf0f00000,
    0x88880000, 0xcccc0000, 0xaaaa0000, 0xffff0000, 
    0x80008000, 0xc000c000, 0xa000a000, 0xf000f000, 
    0x88008800, 0xcc00cc00, 0xaa00aa00, 0xff00ff00,
    0x80808080, 0xc0c0c0c0, 0xa0a0a0a0, 0xf0f0f0f0, 
    0x88888888, 0xcccccccc, 0xaaaaaaaa, 0xffffffff
};
#endif

#endif                                                                          // PBRT_SAMPLERS_Z_COMMON_H
